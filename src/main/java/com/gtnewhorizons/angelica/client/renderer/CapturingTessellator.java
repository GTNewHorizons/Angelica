package com.gtnewhorizons.angelica.client.renderer;

import com.gtnewhorizons.angelica.compat.mojang.VertexFormat;
import com.gtnewhorizons.angelica.compat.nd.Quad;
import com.gtnewhorizons.angelica.compat.nd.RecyclingList;
import me.jellysquid.mods.sodium.client.render.pipeline.BlockRenderer;
import net.minecraft.client.renderer.Tessellator;
import org.lwjgl.BufferUtils;
import org.lwjgl.opengl.GL11;

import java.nio.ByteBuffer;
import java.util.List;

/*
 * To be used in conjunction with the TessellatorManager
 *
 * Used to capture the quads generated by the Tessellator across multiple draw calls and make the quad list available for usage.
 *   Currently being used to generate a VBO for a model and only stores Position, Texture, and Normals.
 *
 * NOTE: This should only be used on the main thread, and will _not_ (currently) capture, integrate, or stop any GL calls made
 * around the tessellator draw calls.
 */
@SuppressWarnings("unused")
public class CapturingTessellator extends Tessellator {
    protected final VertexFormat format;

    private final BlockRenderer.Flags FLAGS = new BlockRenderer.Flags(true, true, true, false);
    private final RecyclingList<Quad> quadBuf = new RecyclingList<>(Quad::new);
    public CapturingTessellator(VertexFormat format) {
        super();
        this.format = format;
    }

    @Override
    public int draw() {
        // Adapted from Neodymium

        FLAGS.hasBrightness = this.hasBrightness;
        FLAGS.hasColor = this.hasColor;

        final int verticesPerPrimitive = this.drawMode == GL11.GL_QUADS ? 4 : 3;

        for(int quadI = 0; quadI < this.vertexCount / verticesPerPrimitive; quadI++) {
            final Quad quad = quadBuf.next();
            quad.setState(this.rawBuffer, quadI * (verticesPerPrimitive * 8), FLAGS, this.drawMode, 0f, 0f, 0f);

            if(quad.deleted) {
                quadBuf.remove();
            }
        }

        final int i = this.rawBufferIndex * 4;
        this.reset();
        this.isDrawing = false;
        return i;
    }

    public List<Quad> getQuads() {
        return quadBuf.getAsList();
    }


    public static ByteBuffer quadsToBuffer(List<Quad> quads, VertexFormat format) {
        final ByteBuffer byteBuffer = BufferUtils.createByteBuffer(format.getVertexSize() * quads.size() * 4);

        // noinspection ForLoopReplaceableByForEach
        for (int i = 0, quadsSize = quads.size(); i < quadsSize; i++) {
            final Quad quad = quads.get(i);
            for (int idx = 0; idx < 4; idx++) {
                // TODO: Actually use the format for deciding what elements to write, currently hardcoded to assume DefaultVertexFormat.VBO

                // Position
                byteBuffer.putFloat(quad.getX(idx));
                byteBuffer.putFloat(quad.getY(idx));
                byteBuffer.putFloat(quad.getZ(idx));

                // Texture
                byteBuffer.putFloat(quad.getTexU(idx));
                byteBuffer.putFloat(quad.getTexV(idx));

                // Normals
                byteBuffer.putInt(quad.getNormal(idx));
            }
        }
        byteBuffer.rewind();
        return byteBuffer;
    }

}
