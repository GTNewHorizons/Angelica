package com.gtnewhorizons.angelica.client.renderer;

import com.gtnewhorizons.angelica.compat.mojang.BlockPos;
import com.gtnewhorizons.angelica.compat.mojang.VertexFormat;
import com.gtnewhorizons.angelica.compat.nd.Quad;
import com.gtnewhorizons.angelica.utils.ObjectPooler;
import it.unimi.dsi.fastutil.objects.ObjectArrayList;
import me.jellysquid.mods.sodium.client.render.pipeline.BlockRenderer;
import net.minecraft.client.renderer.Tessellator;
import org.lwjgl.BufferUtils;
import org.lwjgl.opengl.GL11;

import java.nio.ByteBuffer;
import java.util.List;

/*
 * To be used in conjunction with the TessellatorManager
 *
 * Used to capture the quads generated by the Tessellator across multiple draw calls and make the quad
 * list available for usage.
 *
 * NOTE: This will _not_ (currently) capture, integrate, or stop any GL calls made around the tessellator draw calls.
 *
 */
@SuppressWarnings("unused")
public class CapturingTessellator extends Tessellator {
    private final BlockRenderer.Flags FLAGS = new BlockRenderer.Flags(true, true, true, true);
    private final ObjectPooler<Quad> quadBuf = new ObjectPooler<>(Quad::new);
    private final List<Quad> collectedQuads = new ObjectArrayList<>();

    // Any offset we need to the Tesselator's offset!
    private final BlockPos offset = new BlockPos();

    public void setOffset(BlockPos pos) {
        this.offset.set(pos);
    }

    @Override
    public int draw() {
        // Adapted from Neodymium

        FLAGS.hasBrightness = this.hasBrightness;
        FLAGS.hasColor = this.hasColor;
        FLAGS.hasNormals = this.hasNormals;

        // TODO: Support GL_TRIANGLES
        if(this.drawMode != GL11.GL_QUADS) {
            throw new IllegalStateException("Currently only supports GL_QUADS");

        }
        final int verticesPerPrimitive = this.drawMode == GL11.GL_QUADS ? 4 : 3;


        for(int quadI = 0; quadI < this.vertexCount / verticesPerPrimitive; quadI++) {
            final Quad quad = quadBuf.getInstance();
            quad.setState(this.rawBuffer, quadI * (verticesPerPrimitive * 8), FLAGS, this.drawMode, -offset.x, -offset.y, -offset.z);

            if(quad.deleted) {
                quadBuf.releaseInstance(quad);
            } else {
                this.collectedQuads.add(quad);
            }
        }

        final int i = this.rawBufferIndex * 4;
        this.reset();
        this.isDrawing = false;
        return i;
    }

    @Override
    public void reset() {
        super.reset();
        this.offset.zero();
    }

    public List<Quad> getQuads() {
        return collectedQuads;
    }

    public void clearQuads() {
        //noinspection ForLoopReplaceableByForEach
        for(int i = 0; i < this.collectedQuads.size(); i++) {
            this.quadBuf.releaseInstance(this.collectedQuads.get(i));
        }
        this.collectedQuads.clear();
    }

    public static ByteBuffer quadsToBuffer(List<Quad> quads, VertexFormat format) {
        if(!format.canWriteQuads()) {
            throw new IllegalStateException("Vertex format has no quad writer: " + format);
        }
        final ByteBuffer byteBuffer = BufferUtils.createByteBuffer(format.getVertexSize() * quads.size() * 4);
        // noinspection ForLoopReplaceableByForEach
        for (int i = 0, quadsSize = quads.size(); i < quadsSize; i++) {
            format.writeQuad(quads.get(i), byteBuffer);
        }
        byteBuffer.rewind();
        return byteBuffer;
    }

}
